* License
* Complete control socket handling and protocol
  - support for pinned-start and pinned-stop
  - support for listing all services
* Implement a control utility to start/stop services after dinit has started
  - very basic version exists, needs thorough cleanup
* Service rollback (for shutdown/reboot etc) should unpin pinned-started services.

For version 1.0:
----------------
* Think about shutdown. TTY services:
   - potentially don't respond to SIGTERM (eg interactive bash doesn't, though it
     does to SIGHUP) or even any signal other than SIGKILL.
   - but SIGKILL is a big hammer to wield immediately.
   - termination timeouts could solve this.
   - another way: the option to not wait for the process to terminate as a
     per-service flag (or to wait for a limited time)
   - ideally, we want to signal all processes in the session, not just the session
     leader.
* Re-think handling of crashing daemons. If udevd crashes for example it should not
  bring the whole system down. On the other hand udevd failing to start *should*
  prevent the system from booting further.
   - maybe make it possible to mark services as "once it's up it's up", so eg you
     can mark loginready and/or tty services as such. These services will not
     stop if their dependencies stop. On the other hand this subverts the dependency
     system. ***  Now have this - "pinned started" state.
   - Another possibility is to mark process services so that they will restart the
     process without bringing the service itself down. (Maybe this should be the
     default for auto-restart services anyway).
   - Perhaps also need a way to prevent script services from re-starting.
     (eg there's no need to mount filesystems twice).
* Add command line arg to start in "PID 1" mode (even if PID != 1).
  Basically, allow running as a system service monitor, without
  requiring that dinit runs as PID 1.
* if PID != 1, choose a more sensible service definition directory
  (something like $HOME/dinit.d)
* Documentation including sample service definitions
* Better error handling, logging of errors
* Write wtmp entry on startup (see simpleinit)
* Allow running services as a different UID

For later:
* Allow logging tasks to memory (growing or circular buffer) and later
  switching to disk logging (allows for filesystem mounted readonly on boot)
* Rate control on process respawn
* Maybe re-implement "shutdown" ("halt", "reboot") from util-linux to better work
  with dinit.
* Allow running services with different resource limits, chroot, cgroups,
  namespaces (pid/fs/uid), etc
* Make default control socket location build-time configurable
* Allow specifying a timeout for killing services; if they don't die within
  the timeout (after a TERM) then hit them with a KILL.

Even later:
* Support recognising /etc/init.d services automatically (as script services, with
  no dependency management - or upstart compatible dependency management)
  Also BSD's rc.d style scripts (PROVIDE, REQUIRE).
* Place some reasonable, soft limit on the number of services to be started
  simultaneously, to prevent thrashing. Services that are taking a long time
  to start don't count to the limit. Maybe use CPU/IO usage as a controlling
  factor.
* Cron-like tasks (if started, they run a sub-task periodically. Stopping the
  task will wait until the sub-task is complete). 
* Socket activation of services? Not sure if enough non-SystemD derived
  daemons actually support this to warrant implementing it.
* Allow to run services attached to virtual tty, allow connection to that tty (ala "screen").
* SystemD-like handling of filesystem mounts (see autofs documentation in kernel)
  i.e. a mount point gets an autofs attached, and lazily gets mounted when accessed
  (or is mounted in parallel). Probably put the functionality in a separate daemon.


Documentation:

* What's the best TERM setting? gogetty gives me "linux" but I think other variants may be
  better (eg "linux-c").

* Figure out the ConsoleKit/logind / PolicyKit mess & how dinit needs to fit into it.
  * Consolekit/logind tracks "sessions". Provides a mechanism to mark a session starting,
    associates processes with sessions, provides calls to terminate sessions etc (why?!!)
    Can use environment variable or cgroups to track processes in a session.
    A PAM module exists to create/destroy sessions.
  * Consolekit/logind also allows for requesting shutdown, reboot, and inhibiting reboot
    (via dbus API).
  * "seats" are a set of input/output hardware (mouse/keyboard/monitor) on which a session
    can be run. You can have multiple sessions on a seat - one is in the foreground
    (eg linux virtual ttys implement multiple sessions on a single seat).
    Sessions can run without a seat (eg ssh session).
